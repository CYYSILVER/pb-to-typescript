{"version":3,"file":"index.esm.js","sources":["../src/printField.ts","../src/printMethod.ts","../src/mock.ts","../src/index.ts","../src/printEnum.ts"],"sourcesContent":["import { IType, IField, IMapField } from 'protobufjs';\n\nconst TYPES: {\n  [key: string]: string;\n} = {\n  double: 'number',\n  float: 'number',\n  int32: 'number',\n  int64: 'number',\n  uint32: 'number',\n  uint64: 'number',\n  sint32: 'number',\n  sint64: 'number',\n  fixed32: 'number',\n  fixed64: 'number',\n  sfixed32: 'number',\n  sfixed64: 'number',\n  bool: 'boolean',\n  string: 'string',\n  bytes: 'string'\n};\n\nfunction getKeyType(p: Partial<IMapField>) {\n  if (p.keyType) {\n    return TYPES[p.keyType] || p.keyType;\n  }\n  return '';\n}\n\nfunction readField(\n  name: string,\n  content: {\n    [k: string]: IField;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return {\n      type: TYPES[paramValue.type] || paramValue.type,\n      keyType: getKeyType(paramValue),\n      name: paramName,\n      rule: paramValue.rule,\n      id: paramValue.id\n    };\n  });\n\n  return {\n    category: 'fields',\n    name: name,\n    params: params.sort((a, b) => a.id - b.id)\n  };\n}\n\nexport function printField(name: string, fieldParams: IType) {\n  const content = fieldParams.fields;\n\n  const item = readField(name, content);\n\n  const strs = item.params.map(param => {\n    if (param.rule === 'repeated') {\n      return `  ${param.name}: ${param.type}[];\\n`;\n    }\n    if (param.keyType) {\n      return `  ${param.name}: {[key: ${param.keyType}]: ${param.type}};\\n`;\n    }\n    return `  ${param.name}: ${param.type};\\n`;\n  });\n\n  if (fieldParams.nested) {\n    Object.keys(fieldParams.nested).forEach(key => {\n      strs.push(`  ${key}: ${key};\\n`);\n    });\n  }\n\n  return `interface ${item.name} {\\n${strs.join('')}}\\n\\n`;\n}\n","import { IService, IMethod } from 'protobufjs';\n\nconst EMPTY = 'google.protobuf.Empty';\n\nfunction readMethod(\n  name: string,\n  content: {\n    [k: string]: IMethod;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return { name: paramName, ...paramValue };\n  });\n\n  return {\n    category: 'methods',\n    name: name,\n    params\n  };\n}\n\nexport function printMethod(name: string, methodContent: IService) {\n  const content = methodContent.methods;\n  const item = readMethod(name, content);\n\n  const strs = item.params.map(param => {\n    const requestType =\n      param.requestType === EMPTY ? '' : `params: ${param.requestType}`;\n    const responseType =\n      param.responseType === EMPTY ? '{}' : param.responseType;\n    return (\n      `interface ${param.name} {\\n` +\n      `  (${requestType}): Promise<${responseType}>;\\n` +\n      `}\\n` +\n      `\\n`\n    );\n  });\n\n  return `${strs.join('')}`;\n}\n","import protobuf, { Service, MapField } from 'protobufjs';\n\nfunction _getAllMethods(root: protobuf.Root) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n\n  return firstService.methods;\n}\n\nexport function getAllMethods(source: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _getAllMethods(reflect);\n  }\n  return _getAllMethods(res.root);\n}\n\nfunction mockScalar(type: string): any {\n  switch (type) {\n    case 'string':\n      return 'Hello';\n    case 'number':\n      return 10;\n    case 'bool':\n      return true;\n    case 'int32':\n      return 10;\n    case 'int64':\n      return 20;\n    case 'uint32':\n      return 100;\n    case 'uint64':\n      return 100;\n    case 'sint32':\n      return 100;\n    case 'sint64':\n      return 1200;\n    case 'fixed32':\n      return 1400;\n    case 'fixed64':\n      return 1500;\n    case 'sfixed32':\n      return 1600;\n    case 'sfixed64':\n      return 1700;\n    case 'double':\n      return 1.4;\n    case 'float':\n      return 1.1;\n    case 'bytes':\n      return new Buffer('Hello');\n    default:\n      return null;\n  }\n}\n\nfunction mockType(root: protobuf.Root, typeName: string): Object {\n  const type = root.lookupType(typeName);\n\n  return type.fieldsArray.reduce((a, b) => {\n    if (b instanceof MapField) {\n      const mockKey = mockScalar(b.keyType);\n      const mockData = mockScalar(b.type);\n      const val = mockData\n        ? { [b.name]: { [mockKey]: mockData } }\n        : { [b.name]: { [mockKey]: mockType(root, b.type) } };\n      return { ...a, ...val };\n    }\n    if (b.rule === 'repeated') {\n      const mockData = mockScalar(b.type);\n      const val = mockData\n        ? { [b.name]: [mockData] }\n        : { [b.name]: [mockType(root, b.type)] };\n      return { ...a, ...val };\n    }\n    const mockData = mockScalar(b.type);\n    const val = mockData\n      ? { [b.name]: mockData }\n      : { [b.name]: mockType(root, b.type) };\n    return { ...a, ...val };\n  }, {});\n}\n\nfunction _mockResponse(root: protobuf.Root, methodName: string) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n  const { responseType } = firstService.methods[methodName];\n  const res = mockType(root, responseType);\n  return res;\n}\n\nexport function mockResponse(source: string, methodName: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _mockResponse(reflect, methodName);\n  }\n  return _mockResponse(res.root, methodName);\n}\n","import protobuf, { IService, IType, IEnum } from 'protobufjs';\nimport { printField } from './printField';\nimport { printMethod } from './printMethod';\nimport { printEnum } from './printEnum';\nimport { getAllMethods, mockResponse } from './mock';\n\nexport function printTypescript(json: protobuf.INamespace): string {\n  const nested = json.nested;\n  if (nested) {\n    const output = Object.keys(nested)\n      .map(name => {\n        const value = nested[name];\n\n        const res = Object.keys(value).map(category => {\n          if (category === 'fields') return printField(name, value as IType);\n          if (category === 'methods')\n            return printMethod(name, value as IService);\n          if (category === 'values') return printEnum(name, value as IEnum);\n          if (category === 'nested') return printTypescript(value);\n        });\n        return res;\n      })\n      .reduce((a, b) => a.concat(b), [])\n      .join('');\n\n    return output;\n  }\n  return '';\n}\n\nexport function parseProto(source: string) {\n  const res = protobuf.parse(source, { keepCase: true });\n  if (res.package) {\n    const root = res.root.lookup(res.package);\n    return printTypescript(root!.toJSON());\n  }\n  // console.log(JSON.stringify(res.root.toJSON()));\n  return printTypescript(res.root.toJSON());\n}\n\nexport { getAllMethods, mockResponse };\n\nexport default {\n  parseProto,\n  getAllMethods,\n  mockResponse\n};\n","import { IEnum } from 'protobufjs';\n\nexport function printEnum(name: string, enumContent: IEnum) {\n  const content = enumContent.values;\n  const item = Object.keys(content)\n    .map(key => ({\n      name: key,\n      id: content[key]\n    }))\n    .sort((a, b) => a.id - b.id);\n  const strs = item.map(s => `  ${s.name} = ${s.id},\\n`).join('');\n  return `enum ${name} {\\n${strs}}\\n\\n`;\n}\n"],"names":["const","TYPES","double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes","EMPTY","getAllMethods","source","root","service","res","protobuf","parse","keepCase","alternateCommentMode","package","lookup","nestedArray","find","s","Service","lookupService","name","methods","mockScalar","type","Buffer","mockResponse","methodName","firstService","mockType","typeName","lookupType","fieldsArray","reduce","a","b","MapField","mockKey","keyType","mockData","val","Object","rule","_mockResponse","printTypescript","json","nested","keys","map","value","category","fieldParams","item","content","params","paramName","p","paramValue","id","sort","readField","fields","strs","param","forEach","key","push","join","printField","methodContent","readMethod","requestType","responseType","printMethod","enumContent","values","printEnum","concat","parseProto","toJSON"],"mappings":"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"}