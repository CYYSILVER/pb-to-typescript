{"version":3,"file":"index.js","sources":["../src/printField.ts","../src/printMethod.ts","../src/index.ts"],"sourcesContent":["import { FieldContent } from './interface';\n\nconst TYPES: {\n  [key: string]: string;\n} = {\n  double: 'number',\n  float: 'number',\n  int32: 'number',\n  int64: 'number',\n  uint32: 'number',\n  uint64: 'number',\n  sint32: 'number',\n  sint64: 'number',\n  fixed32: 'number',\n  fixed64: 'number',\n  sfixed32: 'number',\n  sfixed64: 'number',\n  bool: 'boolean',\n  string: 'string',\n  bytes: 'string'\n};\n\nfunction readField(name: string, content: FieldContent) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return {\n      type: TYPES[paramValue.type] || paramValue.type,\n      name: paramName,\n      rule: paramValue.rule,\n      id: paramValue.id\n    };\n  });\n\n  return {\n    category: 'fields',\n    name: name,\n    params: params.sort((a, b) => a.id - b.id)\n  };\n}\n\nexport function printField(name: string, content: FieldContent) {\n  const item = readField(name, content);\n\n  const strs = item.params.map(param => {\n    if (param.rule === 'repeated') {\n      return `  ${param.name}: ${param.type}[];\\n`;\n    }\n    return `  ${param.name}: ${param.type};\\n`;\n  });\n\n  console.log(strs);\n\n  return `interface ${item.name} {\\n${strs.join('')}}\\n\\n`;\n}\n","import { MethodContent } from './interface';\n\nconst EMPTY = 'google.protobuf.Empty';\n\nfunction readMethod(name: string, content: MethodContent) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return { name: paramName, ...paramValue };\n  });\n\n  return {\n    category: 'methods',\n    name: name,\n    params\n  };\n}\n\nexport function printMethod(name: string, content: MethodContent) {\n  const item = readMethod(name, content);\n\n  const strs = item.params.map(param => {\n    const requestType =\n      param.requestType === EMPTY ? '' : `params: ${param.requestType}`;\n    const responseType =\n      param.responseType === EMPTY ? '{}' : param.responseType;\n    return (\n      `interface ${param.name} {\\n` +\n      `  (${requestType}): Promise<${responseType}>;\\n` +\n      `}\\n` +\n      `\\n`\n    );\n  });\n\n  return `${strs.join('')}`;\n}\n","import protobuf from 'protobufjs';\nimport { printField } from './printField';\nimport { printMethod } from './printMethod';\n\nexport function parseJson(json: protobuf.INamespace) {\n  const nested = json.nested;\n  if (nested) {\n    const output = Object.keys(nested)\n      .map(name => {\n        const value = nested[name] as { [key: string]: any };\n\n        const res = Object.keys(value).map(category => {\n          if (category === 'fields') return printField(name, value[category]);\n          if (category === 'methods') return printMethod(name, value[category]);\n        });\n        return res;\n      })\n      .reduce((a, b) => a.concat(b), [])\n      .join('');\n\n    return output;\n  }\n  return '';\n}\n\n// export function loadProto() {\n//   protobuf.load('rpc.proto', (err, root) => {\n//     if (err) {\n//       console.log(err);\n//     } else {\n//       const output = parseJson(root!.toJSON()!);\n//       fs.writeFileSync('rpc.d.ts', output, { encoding: 'utf-8' });\n//     }\n//   });\n// }\n\nexport function parseProto(source: string) {\n  const res = protobuf.parse(source, { keepCase: true });\n  if (res.package) {\n    const root = res.root.lookup(res.package);\n    return parseJson(root!.toJSON());\n  }\n  console.log(JSON.stringify(res.root.toJSON()));\n  return parseJson(res.root.toJSON());\n}\n\nexport default {\n  parseProto,\n  parseJson\n};\n\nparseProto(`\nsyntax = \"proto3\";\nmessage CheckKycInfoMatchResp {\n}\n`);\n"],"names":["TYPES","double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes","EMPTY","parseJson","json","nested","Object","keys","map","name","value","category","content","item","params","paramName","paramValue","type","rule","id","sort","a","b","readField","strs","param","console","log","join","printField","readMethod","requestType","responseType","printMethod","reduce","concat","parseProto","source","res","protobuf","parse","keepCase","package","root","lookup","toJSON","JSON","stringify"],"mappings":"iFAEMA,EAEF,CACFC,OAAQ,SACRC,MAAO,SACPC,MAAO,SACPC,MAAO,SACPC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,QAAS,SACTC,QAAS,SACTC,SAAU,SACVC,SAAU,SACVC,KAAM,UACNC,OAAQ,SACRC,MAAO,UCjBHC,EAAQ,iCCEEC,EAAUC,OAClBC,EAASD,EAAKC,cAChBA,EACaC,OAAOC,KAAKF,GACxBG,aAAIC,OACGC,EAAQL,EAAOI,UAETH,OAAOC,KAAKG,GAAOF,aAAIG,SAChB,WAAbA,WF6BaF,EAAcG,OACjCC,EApBR,SAAmBJ,EAAcG,SAYxB,CACLD,SAAU,SACVF,KAAMA,EACNK,OAdaR,OAAOC,KAAKK,GAASJ,aAAIO,OAChCC,EAAaJ,EAAQG,SAEpB,CACLE,KAAM/B,EAAM8B,EAAWC,OAASD,EAAWC,KAC3CR,KAAMM,EACNG,KAAMF,EAAWE,KACjBC,GAAIH,EAAWG,MAOFC,cAAMC,EAAGC,UAAMD,EAAEF,GAAKG,EAAEH,MAK5BI,CAAUd,EE9BoCC,EAAMC,IFgC3Da,EAAOX,EAAKC,OAAON,aAAIiB,SACR,aAAfA,EAAMP,UACIO,YAAeA,oBAEjBA,YAAeA,sBAG7BC,QAAQC,IAAIH,gBAEQX,cAAgBW,EAAKI,KAAK,YEzCJC,CAAWpB,GAC5B,YAAbE,WDKcF,EAAcG,YAd1C,SAAoBH,EAAcG,SAOzB,CACLD,SAAU,UACVF,KAAMA,SAROH,OAAOC,KAAKK,GAASJ,aAAIO,UAG/BT,kBAAEG,KAAMM,GAFIH,EAAQG,OAahBe,CAAWrB,ECNqCC,EAAMC,IDQjDG,OAAON,aAAIiB,sBAMZA,kBAJbA,EAAMM,cAAgB7B,EAAQ,cAAgBuB,8BAE9CA,EAAMO,eAAiB9B,EAAQ,KAAOuB,EAAMO,4BASjCJ,KAAK,ICrBuBK,CAAYxB,cAIlDyB,gBAAQb,EAAGC,UAAMD,EAAEc,OAAOb,IAAI,IAC9BM,KAAK,IAIH,YAcOQ,EAAWC,OACnBC,EAAMC,EAASC,MAAMH,EAAQ,CAAEI,UAAU,WAC3CH,EAAII,QAECvC,EADMmC,EAAIK,KAAKC,OAAON,EAAII,SACVG,WAEzBnB,QAAQC,IAAImB,KAAKC,UAAUT,EAAIK,KAAKE,WAC7B1C,EAAUmC,EAAIK,KAAKE,WAG5B,MAAe,YACbT,YACAjC,GAGFiC"}