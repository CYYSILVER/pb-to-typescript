{"version":3,"file":"index.umd.js","sources":["../src/printField.ts","../src/printMethod.ts","../src/index.ts","../src/printEnum.ts"],"sourcesContent":["import { IType, IField, IMapField } from 'protobufjs';\n\nconst TYPES: {\n  [key: string]: string;\n} = {\n  double: 'number',\n  float: 'number',\n  int32: 'number',\n  int64: 'number',\n  uint32: 'number',\n  uint64: 'number',\n  sint32: 'number',\n  sint64: 'number',\n  fixed32: 'number',\n  fixed64: 'number',\n  sfixed32: 'number',\n  sfixed64: 'number',\n  bool: 'boolean',\n  string: 'string',\n  bytes: 'string'\n};\n\nfunction getKeyType(p: Partial<IMapField>) {\n  if (p.keyType) {\n    return TYPES[p.keyType] || p.keyType;\n  }\n  return '';\n}\n\nfunction readField(\n  name: string,\n  content: {\n    [k: string]: IField;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return {\n      type: TYPES[paramValue.type] || paramValue.type,\n      keyType: getKeyType(paramValue),\n      name: paramName,\n      rule: paramValue.rule,\n      id: paramValue.id\n    };\n  });\n\n  return {\n    category: 'fields',\n    name: name,\n    params: params.sort((a, b) => a.id - b.id)\n  };\n}\n\nexport function printField(name: string, fieldParams: IType) {\n  const content = fieldParams.fields;\n\n  const item = readField(name, content);\n\n  const strs = item.params.map(param => {\n    if (param.rule === 'repeated') {\n      return `  ${param.name}: ${param.type}[];\\n`;\n    }\n    if (param.keyType) {\n      return `  ${param.name}: {[key: ${param.keyType}]: ${param.type}};\\n`;\n    }\n    return `  ${param.name}: ${param.type};\\n`;\n  });\n\n  if (fieldParams.nested) {\n    Object.keys(fieldParams.nested).forEach(key => {\n      strs.push(`  ${key}: ${key};\\n`);\n    });\n  }\n\n  return `interface ${item.name} {\\n${strs.join('')}}\\n\\n`;\n}\n","import { IService, IMethod } from 'protobufjs';\n\nconst EMPTY = 'google.protobuf.Empty';\n\nfunction readMethod(\n  name: string,\n  content: {\n    [k: string]: IMethod;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return { name: paramName, ...paramValue };\n  });\n\n  return {\n    category: 'methods',\n    name: name,\n    params\n  };\n}\n\nexport function printMethod(name: string, methodContent: IService) {\n  const content = methodContent.methods;\n  const item = readMethod(name, content);\n\n  const strs = item.params.map(param => {\n    const requestType =\n      param.requestType === EMPTY ? '' : `params: ${param.requestType}`;\n    const responseType =\n      param.responseType === EMPTY ? '{}' : param.responseType;\n    return (\n      `interface ${param.name} {\\n` +\n      `  (${requestType}): Promise<${responseType}>;\\n` +\n      `}\\n` +\n      `\\n`\n    );\n  });\n\n  return `${strs.join('')}`;\n}\n","import protobuf, { IService, IType, IEnum } from 'protobufjs';\nimport { printField } from './printField';\nimport { printMethod } from './printMethod';\nimport { printEnum } from './printEnum';\n\nexport function parseJson(json: protobuf.INamespace): string {\n  const nested = json.nested;\n  if (nested) {\n    const output = Object.keys(nested)\n      .map(name => {\n        const value = nested[name];\n\n        const res = Object.keys(value).map(category => {\n          if (category === 'fields') return printField(name, value as IType);\n          if (category === 'methods')\n            return printMethod(name, value as IService);\n          if (category === 'values') return printEnum(name, value as IEnum);\n          if (category === 'nested') return parseJson(value);\n        });\n        return res;\n      })\n      .reduce((a, b) => a.concat(b), [])\n      .join('');\n\n    return output;\n  }\n  return '';\n}\n\n// export function loadProto() {\n//   protobuf.load('rpc.proto', (err, root) => {\n//     if (err) {\n//       console.log(err);\n//     } else {\n//       const output = parseJson(root!.toJSON()!);\n//       fs.writeFileSync('rpc.d.ts', output, { encoding: 'utf-8' });\n//     }\n//   });\n// }\n\nexport function parseProto(source: string) {\n  const res = protobuf.parse(source, { keepCase: true });\n  if (res.package) {\n    const root = res.root.lookup(res.package);\n    return parseJson(root!.toJSON());\n  }\n  // console.log(JSON.stringify(res.root.toJSON()));\n  return parseJson(res.root.toJSON());\n}\n\nexport default {\n  parseProto,\n  parseJson\n};\n","import { IEnum } from 'protobufjs';\n\nexport function printEnum(name: string, enumContent: IEnum) {\n  const content = enumContent.values;\n  const item = Object.keys(content)\n    .map(key => ({\n      name: key,\n      id: content[key]\n    }))\n    .sort((a, b) => a.id - b.id);\n  const strs = item.map(s => `  ${s.name} = ${s.id},\\n`).join('');\n  return `enum ${name} {\\n${strs}}\\n\\n`;\n}\n"],"names":["const","TYPES","double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes","EMPTY","parseJson","json","nested","Object","keys","map","name","value","category","fieldParams","item","content","params","paramName","p","paramValue","type","keyType","rule","id","sort","a","b","readField","fields","strs","param","forEach","key","push","join","printField","methodContent","readMethod","methods","requestType","responseType","printMethod","enumContent","values","s","printEnum","reduce","concat","parseProto","source","res","protobuf","parse","keepCase","package","root","lookup","toJSON"],"mappings":"iRAEAA,IAAMC,EAEF,CACFC,OAAQ,SACRC,MAAO,SACPC,MAAO,SACPC,MAAO,SACPC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,QAAS,SACTC,QAAS,SACTC,SAAU,SACVC,SAAU,SACVC,KAAM,UACNC,OAAQ,SACRC,MAAO,UCjBHC,EAAQ,iCCGEC,EAAUC,OAClBC,EAASD,EAAKC,cAChBA,EACaC,OAAOC,KAAKF,GACxBG,aAAIC,OACGC,EAAQL,EAAOI,UAETH,OAAOC,KAAKG,GAAOF,aAAIG,SAChB,WAAbA,WFyCaF,EAAcG,OAGjCC,EA5BR,SACEJ,EACAK,SAgBO,CACLH,SAAU,SACVF,KAAMA,EACNM,OAfaT,OAAOC,KAAKO,GAASN,aAAIQ,OAbtBC,EAcVC,EAAaJ,EAAQE,SAEpB,CACLG,KAAMjC,EAAMgC,EAAWC,OAASD,EAAWC,KAC3CC,SAlBcH,EAkBMC,EAjBpBD,EAAEG,QACGlC,EAAM+B,EAAEG,UAAYH,EAAEG,QAExB,IAeHX,KAAMO,EACNK,KAAMH,EAAWG,KACjBC,GAAIJ,EAAWI,MAOFC,cAAMC,EAAGC,UAAMD,EAAEF,GAAKG,EAAEH,MAO5BI,CAAUjB,EAFPG,EAAYe,QAItBC,EAAOf,EAAKE,OAAOP,aAAIqB,SACR,aAAfA,EAAMR,UACIQ,YAAeA,eAEzBA,EAAMT,aACIS,mBAAsBA,gBAAmBA,mBAE3CA,YAAeA,sBAGzBjB,EAAYP,QACdC,OAAOC,KAAKK,EAAYP,QAAQyB,iBAAQC,GACtCH,EAAKI,UAAUD,OAAQA,wBAIPlB,cAAgBe,EAAKK,KAAK,YE9DJC,CAAWzB,EAAMC,GAClC,YAAbC,WDScF,EAAc0B,YAnB1C,SACE1B,EACAK,SAUO,CACLH,SAAU,UACVF,KAAMA,SAROH,OAAOC,KAAKO,GAASN,aAAIQ,UAG/BV,kBAAEG,KAAMO,GAFIF,EAAQE,OAchBoB,CAAW3B,ECVWC,EDSL2B,SAGZtB,OAAOP,aAAIqB,sBAMZA,kBAJbA,EAAMS,cAAgBpC,EAAQ,cAAgB2B,8BAE9CA,EAAMU,eAAiBrC,EAAQ,KAAO2B,EAAMU,4BASjCN,KAAK,ICzBHO,CAAY/B,GACJ,WAAbE,WCdYF,EAAcgC,OAChC3B,EDaoDJ,ECb9BgC,qBAQbjC,SAPFH,OAAOC,KAAKO,GACtBN,aAAIuB,UACHtB,KAAMsB,EACNT,GAAIR,EAAQiB,MAEbR,cAAMC,EAAGC,UAAMD,EAAEF,GAAKG,EAAEH,KACTd,aAAImC,cAAUA,aAAYA,aAAWV,KAAK,YDMlBW,CAAUnC,GAC3B,WAAbE,EAA8BR,EAAUO,cAI/CmC,gBAAQrB,EAAGC,UAAMD,EAAEsB,OAAOrB,IAAI,IAC9BQ,KAAK,IAIH,YAcOc,EAAWC,OACnBC,EAAMC,EAASC,MAAMH,EAAQ,CAAEI,UAAU,WAGtCjD,EAFL8C,EAAII,QACOJ,EAAIK,KAAKC,OAAON,EAAII,SACVG,SAGRP,EAAIK,KAAKE,gBAGb,YACbT,YACA5C"}