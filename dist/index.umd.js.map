{"version":3,"file":"index.umd.js","sources":["../src/printField.ts","../src/printMethod.ts","../src/mock.ts","../src/index.ts","../src/printEnum.ts"],"sourcesContent":["import { IType, IField, IMapField } from 'protobufjs';\n\nconst TYPES: {\n  [key: string]: string;\n} = {\n  double: 'number',\n  float: 'number',\n  int32: 'number',\n  int64: 'number',\n  uint32: 'number',\n  uint64: 'number',\n  sint32: 'number',\n  sint64: 'number',\n  fixed32: 'number',\n  fixed64: 'number',\n  sfixed32: 'number',\n  sfixed64: 'number',\n  bool: 'boolean',\n  string: 'string',\n  bytes: 'string'\n};\n\nfunction getKeyType(p: Partial<IMapField>) {\n  if (p.keyType) {\n    return TYPES[p.keyType] || p.keyType;\n  }\n  return '';\n}\n\nfunction readField(\n  name: string,\n  content: {\n    [k: string]: IField;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return {\n      type: TYPES[paramValue.type] || paramValue.type,\n      keyType: getKeyType(paramValue),\n      name: paramName,\n      rule: paramValue.rule,\n      id: paramValue.id\n    };\n  });\n\n  return {\n    category: 'fields',\n    name: name,\n    params: params.sort((a, b) => a.id - b.id)\n  };\n}\n\nexport function printField(name: string, fieldParams: IType) {\n  const content = fieldParams.fields;\n\n  const item = readField(name, content);\n\n  const strs = item.params.map(param => {\n    if (param.rule === 'repeated') {\n      return `  ${param.name}: ${param.type}[];\\n`;\n    }\n    if (param.keyType) {\n      return `  ${param.name}: {[key: ${param.keyType}]: ${param.type}};\\n`;\n    }\n    return `  ${param.name}: ${param.type};\\n`;\n  });\n\n  if (fieldParams.nested) {\n    Object.keys(fieldParams.nested).forEach(key => {\n      strs.push(`  ${key}: ${key};\\n`);\n    });\n  }\n\n  return `interface ${item.name} {\\n${strs.join('')}}\\n\\n`;\n}\n","import { IService, IMethod } from 'protobufjs';\n\nconst EMPTY = 'google.protobuf.Empty';\n\nfunction readMethod(\n  name: string,\n  content: {\n    [k: string]: IMethod;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return { name: paramName, ...paramValue };\n  });\n\n  return {\n    category: 'methods',\n    name: name,\n    params\n  };\n}\n\nexport function printMethod(name: string, methodContent: IService) {\n  const content = methodContent.methods;\n  const item = readMethod(name, content);\n\n  const strs = item.params.map(param => {\n    const requestType =\n      param.requestType === EMPTY ? '' : `params: ${param.requestType}`;\n    const responseType =\n      param.responseType === EMPTY ? '{}' : param.responseType;\n    return (\n      `interface ${param.name} {\\n` +\n      `  (${requestType}): Promise<${responseType}>;\\n` +\n      `}\\n` +\n      `\\n`\n    );\n  });\n\n  return `${strs.join('')}`;\n}\n","import protobuf, { Service } from 'protobufjs';\n\nfunction _getAllMethods(root: protobuf.Root) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n\n  return firstService.methods;\n}\n\nexport function getAllMethods(source: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _getAllMethods(reflect);\n  }\n  return _getAllMethods(res.root);\n}\n\nfunction mockScalar(type: string): any {\n  switch (type) {\n    case 'string':\n      return 'Hello';\n    case 'number':\n      return 10;\n    case 'bool':\n      return true;\n    case 'int32':\n      return 10;\n    case 'int64':\n      return 20;\n    case 'uint32':\n      return 100;\n    case 'uint64':\n      return 100;\n    case 'sint32':\n      return 100;\n    case 'sint64':\n      return 1200;\n    case 'fixed32':\n      return 1400;\n    case 'fixed64':\n      return 1500;\n    case 'sfixed32':\n      return 1600;\n    case 'sfixed64':\n      return 1700;\n    case 'double':\n      return 1.4;\n    case 'float':\n      return 1.1;\n    case 'bytes':\n      return new Buffer('Hello');\n    default:\n      return null;\n  }\n}\n\nfunction mockType(root: protobuf.Root, typeName: string): Object {\n  const type = root.lookupType(typeName);\n\n  return type.fieldsArray.reduce((a, b) => {\n    if (b.rule === 'repeated') {\n      const mockData = mockScalar(b.type);\n      const val = mockData\n        ? { [b.name]: [mockData] }\n        : { [b.name]: [mockType(root, b.type)] };\n      return { ...a, ...val };\n    }\n    const mockData = mockScalar(b.type);\n    const val = mockData\n      ? { [b.name]: mockData }\n      : { [b.name]: mockType(root, b.type) };\n    return { ...a, ...val };\n  }, {});\n}\n\nfunction _mockResponse(root: protobuf.Root, methodName: string) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n  const { responseType } = firstService.methods[methodName];\n  const res = mockType(root, responseType);\n  return res;\n}\n\nexport function mockResponse(source: string, methodName: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _mockResponse(reflect, methodName);\n  }\n  return _mockResponse(res.root, methodName);\n}\n","import protobuf, { IService, IType, IEnum } from 'protobufjs';\nimport { printField } from './printField';\nimport { printMethod } from './printMethod';\nimport { printEnum } from './printEnum';\nimport { getAllMethods, mockResponse } from './mock';\n\nexport function printTypescript(json: protobuf.INamespace): string {\n  const nested = json.nested;\n  if (nested) {\n    const output = Object.keys(nested)\n      .map(name => {\n        const value = nested[name];\n\n        const res = Object.keys(value).map(category => {\n          if (category === 'fields') return printField(name, value as IType);\n          if (category === 'methods')\n            return printMethod(name, value as IService);\n          if (category === 'values') return printEnum(name, value as IEnum);\n          if (category === 'nested') return printTypescript(value);\n        });\n        return res;\n      })\n      .reduce((a, b) => a.concat(b), [])\n      .join('');\n\n    return output;\n  }\n  return '';\n}\n\nexport function parseProto(source: string) {\n  const res = protobuf.parse(source, { keepCase: true });\n  if (res.package) {\n    const root = res.root.lookup(res.package);\n    return printTypescript(root!.toJSON());\n  }\n  // console.log(JSON.stringify(res.root.toJSON()));\n  return printTypescript(res.root.toJSON());\n}\n\nexport { getAllMethods, mockResponse };\n\nexport default {\n  parseProto,\n  getAllMethods,\n  mockResponse\n};\n","import { IEnum } from 'protobufjs';\n\nexport function printEnum(name: string, enumContent: IEnum) {\n  const content = enumContent.values;\n  const item = Object.keys(content)\n    .map(key => ({\n      name: key,\n      id: content[key]\n    }))\n    .sort((a, b) => a.id - b.id);\n  const strs = item.map(s => `  ${s.name} = ${s.id},\\n`).join('');\n  return `enum ${name} {\\n${strs}}\\n\\n`;\n}\n"],"names":["TYPES","double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes","EMPTY","getAllMethods","source","root","service","res","protobuf","parse","keepCase","alternateCommentMode","package","lookup","nestedArray","find","s","Service","lookupService","name","methods","mockScalar","type","Buffer","mockResponse","methodName","firstService","mockType","typeName","lookupType","fieldsArray","reduce","a","b","rule","mockData","val","Object","_mockResponse","printTypescript","json","nested","keys","map","value","category","fieldParams","item","content","params","paramName","p","paramValue","keyType","id","sort","readField","fields","strs","param","forEach","key","push","join","printField","methodContent","readMethod","requestType","responseType","printMethod","enumContent","values","printEnum","concat","parseProto","toJSON"],"mappings":"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"}